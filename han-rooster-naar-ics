#!/usr/bin/env bash
##
## script that generates valid ics files out of gp untis web exports
## of timetable/roster data for a fixed group ($group_id), starting
## with the current week and advancing $weeks_ahead weeks ahead.
##
## resulting ics can be validated using
## http://icalendar.org/validator.html
## or the PHP Sabre\VObject\Reader class
##
##  Copyright (C) 2017 Ronald van Engelen <ronalde+github@lacocina.nl>
##  This program is free software: you can redistribute it and/or modify
##  it under the terms of the GNU General Public License as published by
##  the Free Software Foundation, either version 3 of the License, or
##  (at your option) any later version.
##
##  This program is distributed in the hope that it will be useful,
##  but WITHOUT ANY WARRANTY; without even the implied warranty of
##  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
##  GNU General Public License for more details.
##
##  You should have received a copy of the GNU General Public License
##  along with this program.  If not, see <http://www.gnu.org/licenses/>.
##
## Source and documentation:
##  https://github.com/ronalde/han-rooster-naar-ics

## shellcheck exceptions
# shellcheck disable=SC2086
# shellcheck disable=SC2116
# shellcheck disable=SC2181
# shellcheck disable=SC1090

app_name="han-rooster-naar-ics"
app_info_url="https://github.com/ronalde/${app_name}"

default_courses_csv_filename="data/courses.csv"
default_teachers_csv_filename="data/teachers.csv"
default_lessonduration_minutes=45
default_weeks_ahead=12
default_standard_group_size=15
default_csv_sep=";"
default_ics_organizer_email="someone@example.org"
default_ics_organizer_cn="${app_name}"
default_ics_organizer_sentby_email="${app_name}@example.org"
default_people_lookup_url_base="https://example.org/people?"
default_ics_organizer_dirurl="${default_people_lookup_url_base}q="

function display_usageinfo() {
    msg_usage="\
Usage:
${app_name} -u|--roster-url URL -g|--group-name GROUPNAME [optional arguments]
 - or -
${app_name} PATHTOSETTINGSFILE

Translate a published Untis roster for a group to a valid iCalendar
(ICS) file.

REQUIRED ARGUMENTS
 -u|--roster-url URL               The full URL of the published Untis roster.
 -g|--group-name GROUPNAME         The full name of the group for which the 
 		 		   roster should be fetched.

OPTIONAL ARGUMENTS
 -o|--output-path PATH     	   Defaults to GROUPNAME_CURRENTDATE.ics in current dir.
 -l|--symlink-names LINKNAME [LINKNAME]
       When set, a symbolic link will be created to output_path in the
       directory where output_path is stored. Expects a single link
       name or a space separated list of link names.
 -d|--lessons-duration-minutes INT Defaults to ${default_lessonduration_minutes}
 -s|--standard-group-size INT  	   Defaults to ${default_standard_group_size}
 -a|--weeks-ahead INT	     	   Defaults to ${default_weeks_ahead}
 -t|--teachers-csv-path PATH	   Path to the csv file containing
       information on teachers. Defaults to \`${default_teachers_csv_filename}' in current
       directory.
 -c|--courses-csv-path PATH	   Path to the csv file containing
       information on courses. Defaults to \`${default_courses_csv_filename}' in current
       directory.
 --temp-storage-dir PATH	   PATH to the directory to store
       temporary ics snippets. Old ics files found in this directory
       are used in the final ics file, so set this to retain
       historical information.
 --ics-organizer-email ADDRESS	   Sets the MAILTO organizer field to ADDRESS in the ics.
 --ics-organizer-cn COMMON_NAME	   Sets the CN organizer field to COMMON_NAME in the ics.
 --ics-organizer-sentby-email ADDRESS 
                                   Sets the SENTBY:MAILTO organizer field to ADDRESS 
        			   in the ics.
 --people-lookup-url URL	   URL is used in the instruction displayed when a teacher 
       is not found in the teachers csv file.
 -wo|--overwrite-output            If set, overwrites the output ics file when it exists.
 -ws|--overwrite-symlinks          If set, overwrites existing symlinks (but not files 
       or directories).

Background information:
${app_info_url}
"
    printf 1>&2 "%s\n" "${msg_usage}"
}

function die() {
    [[ ${#@} -gt 0 ]] && msg_err="S"
    printf "FATAL ERROR${msg_err}:\n%s\n\n" "$@" 1>&2
    display_usageinfo
    exit 1
}

function analyze_command_line() {
    ## parse command line arguments using the `manual loop` method
    ## described in http://mywiki.wooledge.org/BashFAQ/035.
    while :; do
        case "${1:-}" in
            -u|--roster-url)
		if [[ "${2}x" == "x" ]]; then
		    die "argument \`$1' requires a valid URL."
		else
		    arg_roster_url="$2"
		    shift 2
                    continue
		fi
		;;
	    -g|--group-name)
		if [[ "${2}x" == "x" ]]; then
		    die "argument \`$1' requires a valid GROUPNAME."
		else
		    arg_group_name="${2}"
		    shift 2
                    continue
		fi
		;;
            -o|--output-path)
		if [[ "${2}x" == "x" ]]; then
		    die "argument \`$1' requires a valid PATH."
		else
		    arg_output_path="$2"
		    shift 2
                    continue
		fi
		;;
            -l|--symlink-names)
		if [[ "${2}x" == "x" ]]; then
		    die "argument \`$1' requires a valid PATH."
		else
		    arg_symlink_names="$2"
		    shift 2
                    continue
		fi
		;;
	    -s|--standard-group-size)
		if [[ "${2}x" == "x" ]]; then
                    die "argument \`$1' requires a valid standard GROUPSIZE."
		else
		    arg_standard_group_size="${2}"
		    if [[ ${arg_standard_group_size} -lt 1 ]]; then
			die "argument \`$1' requires a valid standard GROUPSIZE (>0)."
		    else
			shift 2
			continue
		    fi
		fi
		;;
            -a|--weeks-ahead)
		if [[ "${2}x" == "x" ]]; then
                    die "argument \`$1' requires a valid number."
		    break
		else
		    arg_weeks_ahead="$2"
		    if [[ ${arg_weeks_ahead} -lt 1 ]]; then
			die "argument \`$1' requires a valid number (>0)."
		    else
			shift 2
			continue
		    fi
		fi
		;;
            -l|--lessons-duration-minutes)
		if [[ "${2}x" == "x" ]]; then
                    die "argument \`$1' requires a valid number."
		    break
		else
		    arg_lessonduration_minutes="$2"
		    if [[ ${arg_lessonduration_minutes} -lt 1 ]]; then
			die "argument \`$1' requires a valid number (>0)."
		    else
			shift 2
			continue
		    fi
		fi
		;;
            --ics-organizer-email)
		if [[ "${2}x" == "x" ]]; then
                    die "argument \`$1' requires a non-empty string."
		    break
		else
		    arg_ics_organizer_email="$2"
		    shift 2
		    continue
		fi
		;;
            --ics-organizer-cn)
		if [[ "${2}x" == "x" ]]; then
                    die "argument \`$1' requires a non-empty string."
		    break
		else
		    arg_ics_organizer_cn="$2"
		    shift 2
		    continue
		fi
		;;
            --ics-organizer-sentby-email)
		if [[ "${2}x" == "x" ]]; then
                    die "argument \`$1' requires a non-empty string."
		    break
		else
		    arg_ics_organizer_sentby_email="$2"
		    shift 2
		    continue
		fi
		;;
            --people-lookup-url)
		if [[ "${2}x" == "x" ]]; then
                    die "argument \`$1' requires a non-empty string."
		    break
		else
		    arg_people_lookup_url_base="$2"
		    shift 2
		    continue
		fi
		;;
            --ics-organizer-dirurl)
		if [[ "${2}x" == "x" ]]; then
                    die "argument \`$1' requires a non-empty string."
		    break
		else
		    arg_ics_organizer_dirurl="$2"
		    shift 2
		    continue
		fi
		;;
            -t|--teachers-csv-path)
		if [[ "${2}x" == "x" ]]; then
		    die "argument \`$1' requires a valid PATH."
		else
		    arg_teachers_csv_path="$2"
		    shift 2
                    continue
		fi
		;;
            -c|--courses-csv-path)
		if [[ "${2}x" == "x" ]]; then
		    die "argument \`$1' requires a valid PATH."
		else
		    arg_courses_csv_path="$2"
		    shift 2
                    continue
		fi
		;;	    
            --temp-storage-dir)
		if [[ "${2}x" == "x" ]]; then
		    die "argument \`$1' requires a valid PATH."
		else
		    arg_temp_storage_dir="$2"
		    shift 2
                    continue
		fi
		;;	    
            -wo|--overwrite-output)
		arg_overwrite_output=True
		shift
                continue
		;;	    
            -ws|--overwrite-symlinks)
		arg_overwrite_symlinks=True
		shift
                continue
		;;	    
	    -\?|--help)
		display_usageinfo
		exit
		;;
            --)
		shift
		break
		;;
	    -?*)
		printf "Notice: unknown option \`%s' ignored\n\n." "$1" 1>&2
		display_usageinfo
		exit
		;;
            *)
		break
        esac
    done
    if [[ "$*x" != "x" ]]; then
	## settings file specified
	arg_settings_file="$*"
    fi
    if [[ "${arg_settings_file}x" == "x" ]]; then
	## analyze command line arguments and set appropriate variables
	overwrite_output="${arg_overwrite_output}"
	overwrite_symlinks="${arg_overwrite_symlinks}"
	roster_url="${arg_roster_url}"
	group_name="${arg_group_name}"
	output_path="${arg_output_path:-${curdir}/${group_name}_$(date +'%Y%m%dT%H%M%S').ics}"
	a_symlink_names=(${arg_symlink_names:-})
	temp_storage_dir="${arg_temp_storage_dir}"
	standard_group_size="${arg_standard_group_size:-${default_standard_group_size}}"
	weeks_ahead="${arg_weeks_ahead:-${default_weeks_ahead}}"
	lessonduration_minutes="${arg_lessonduration_minutes:-${default_lessonduration_minutes}}"
	ics_organizer_email="${arg_ics_organizer_email:-${default_ics_organizer_email}}"
	ics_organizer_cn="${arg_ics_organizer_cn:-${default_ics_organizer_cn}}"
	ics_organizer_sentby_email="${arg_ics_organizer_sentby_email:-${default_ics_organizer_sentby_email}}"
	people_lookup_url_base="${arg_people_lookup_url_base:-${default_people_lookup_url_base}}"
	ics_organizer_dirurl="${arg_ics_organizer_dirurl:-${default_ics_organizer_dirurl}}"
	csv_paths["courses"]="${arg_courses_csv_path:-${curdir}/${default_courses_csv_filename}}"
	csv_paths["teachers"]="${arg_teachers_csv_path:-${curdir}/${default_teachers_csv_filename}}"
	if [[ "${arg_roster_url}x" == "x" ]] && [[ "${roster_url}x" == "x" ]]; then
	    errors+=("required argument -u|--roster-url not specfied.")
	fi
	if [[ "${arg_group_name}x" == "x" ]] && [[ "${group_name}x" == "x"  ]]; then
	    errors+=("required argument -g|--group-name not specfied.")
	fi
	if [[ ${#errors[@]} -gt 0 ]]; then
	    printf -v msg_error "%s\n" "${errors[@]}"
	    die "${msg_error}"
	fi
	printf 1>&2 " done.\n"
    else
	## source settings file to fill variables
	if [[ ! -f "${arg_settings_file}" ]]; then
	    die "error: specified settings file \`${arg_settings_file}' not found."
	else
	    printf 1>&2 " done.\n"
	    printf 1>&2 "%3s- sourcing settings file \`%s' ... " \
			" " "${arg_settings_file}"
	    source "${arg_settings_file}"
	    if [[ $? -ne 0 ]]; then
		die "error sourcing settings file\`${arg_settings_file}'"
	    else
		printf 1>&2 " done.\n"
	    fi
	    overwrite_output="${overwrite_output:-}"
	    overwrite_symlinks="${overwrite_symlinks:-}"
	    #roster_url="${roster_url}"
	    #group_name="${group_name}"
	    printf -v timestamp '%(%Y%m%dT%H%M%S)T'
	    output_path="${output_path:-${curdir}/${group_name}_${timestamp}.ics}"
	    a_symlink_names=(${symlink_names:-})
	    temp_storage_dir="${temp_storage_dir:-}"
	    standard_group_size="${standard_group_size:-${default_standard_group_size}}"
	    weeks_ahead="${weeks_ahead:-${default_weeks_ahead}}"
	    lessonduration_minutes="${lessonduration_minutes:-${default_lessonduration_minutes}}"
	    ics_organizer_email="${ics_organizer_email:-${default_ics_organizer_email}}"
	    ics_organizer_cn="${ics_organizer_cn:-${default_ics_organizer_cn}}"
	    ics_organizer_sentby_email="${ics_organizer_sentby_email:-${default_ics_organizer_sentby_email}}"	
	    people_lookup_url_base="${people_lookup_url_base:-${default_people_lookup_url_base}}"
	    ics_organizer_dirurl="${ics_organizer_dirurl:-${default_ics_organizer_dirurl}}"
	    csv_paths["courses"]="${courses_csv_path:-${curdir}/${default_courses_csv_filename}}"
	    csv_paths["teachers"]="${teachers_csv_path:-${curdir}/${default_teachers_csv_filename}}"
	fi
    fi
    if [[ "${roster_url}x" == "x" ]]; then
	errors+=("required argument -u|--roster-url not specified.")
    fi
    if  [[ "${group_name}x" == "x"  ]]; then
	errors+=("required argument -g|--group-name not specified.")
    fi
    if [[ ${#errors[@]} -gt 0 ]]; then
	printf -v msg_error "%s\n" "${errors[@]}"
	die "${msg_error}"
    fi

}

function array_from_csv() {
    ## fill $1 (labels_teachers or labels_courses) arrays by reading
    ## in $2 fields from csv files.
    datatype="$1"
    fieldcount="$2"
    csvfile="${csv_paths[${datatype}]}"
    sep="${3:-${default_csv_sep}}"
    ## construct regular expression for fieldcount number of csv
    ## records.
    match_re="([^${sep}]+)${sep}"
    for (( i=1; i<fieldcount; i++)); do
	match_re="${match_re}([^${sep}]+)"
	if (( i < (( fieldcount - 1 )) )); then
	    match_re="${match_re}${sep}"
	fi
    done
    match_re="${match_re}[${sep}]*"
    if [[ ! -f "${csvfile}" ]]; then
	printf 1>&2 "warning in %s: no %s csv file found in \`%s'.\n" \
		    "${FUNCNAME[0]}" "${datatype}" "${csvfile}"
	return 1
    else
	printf 1>&2 "%3s- getting %s from \`%s' ..." \
		    " " "${datatype}" "${csvfile}"
    fi
    case "${datatype}" in
	courses)
	    ## bi;Biology
	    ## shortcut;full_description
	    coursecounter=0
	    while read -r line; do
		if [[ "${line}" =~ ${match_re} ]]; then
		    ((coursecounter++))
		    course_shortcut="${BASH_REMATCH[1]}"
		    course_fullname="${BASH_REMATCH[2]}"
		    labels_courses["${course_shortcut}"]="${course_fullname}"
		else
		    printf 1>&2 "warning in %s: malformed line in csv file \`%s' using match_re \`%s':\n%s\n" \
				"${FUNCNAME[0]}" "${csvfile}" "${match_re}" "${line}"
		    continue
		fi
	    done< "${csvfile}"
	    if [[ ${#labels_courses[@]} -lt 1 ]]; then
		printf 1>&2 "encountered errors:\nno courses found.\n" \
			    
			    return 1
	    else
		printf 1>&2 "done.\n"
		printf 1>&2 "%5s* %d courses found.\n" \
			    " " "${#labels_courses[@]}"
	    fi
	    ;;
	teachers)
	    ## BDSW;Wendy Broeders;docent;Wendy.Broeders@han.nl;5973
	    ## shortcut;full name;jobtitle;email;dirid
	    teachercounter=0
	    while read -r line; do
		if [[ "${line}" =~ ${match_re} ]]; then
		    ((teachercounter++))
		    teacher_shortcut="${BASH_REMATCH[1]}"
		    teacher_fullname="${BASH_REMATCH[2]}"
		    teacher_jobtitle="${BASH_REMATCH[3]}"
		    teacher_email="${BASH_REMATCH[4]}"
		    teacher_dirid="${BASH_REMATCH[5]}"
		    teacher_details="(${teacher_jobtitle}) mailto:${teacher_email} dir:id=${teacher_dirid}"
		    labels_teachers["${teacher_shortcut}"]="${teacher_fullname} ${teacher_details}"
		else
		    printf 1>&2 "warning in %s: malformed line in %s csv file \`%s' using match_re \`%s':\n%s\n" \
				"${FUNCNAME[0]}" "${datatype}" "${csvfile}" "${match_re}" "${line}"
		    continue
		fi
	    done< "${csvfile}"
	    if [[ ${#labels_teachers[@]} -lt 1 ]]; then
		printf 1>&2 "errors encountered.\nno teachers found.\n"
		return 1
	    else
		printf 1>&2 "done.\n"
		printf 1>&2 "%5s* %d teachers found.\n" \
			    " " "${#labels_teachers[@]}"
	    fi
	    ;;
    esac
}

function replace_newline_with_crlf() {
    ## convert all newline characters ('\n') to crlf ('\r\n')
    inputfile="$1"
    outputfile="$2"
    set -f
    IFS='
'
    # shellcheck disable=SC2046
    printf '%s\r\n' $(cat "${inputfile}")  > "${outputfile}"
}

function wrap_lines() {
    ## Lines of text SHOULD NOT be longer than 75 octets, excluding
    ## the line break. Long content lines SHOULD be split into a
    ## multiple line representations using a line "folding"
    ## technique. That is, a long line can be split between any two
    ## characters by inserting a CRLF immediately followed by a single
    ## linear white-space character (i.e., SPACE or HTAB). Any
    ## sequence of CRLF followed immediately by a single linear
    ## white-space character is ignored (i.e., removed) when
    ## processing the content type.
    ## http://icalendar.org/iCalendar-RFC-5545/3-1-content-lines.html
    input_text="$(echo ${1//\\n/})"
    i=0
    chars=73
    while [[ -n "${input_text:$((chars*i)):${chars}}" ]]; do
	if [[ ${i} -eq 0 ]]; then
	    ## first line; just wrap
	    printf "%s\n" "${input_text:0:${chars}}"
	else
	    ## consequtive lines; start with space and wrap
	    printf " %s\n" "${input_text:$((chars*i)):${chars}}"
	fi
	((i++))
    done
}

function ret_group_id() {
    ## return group_id for group_name $1 from roster_url
    group_name="$1"
    local group_id=
    group_option_re="option value=\"([0-9]+)\">(${group_name,,})</option"
    curl_params=(--silent)
    while read -r line; do
	if [[ "${line,,}" =~ ${group_option_re} ]]; then
	    group_id="${BASH_REMATCH[1]}"   
	    break
	fi
    done < <(${cmd_curl} "${curl_params[@]}" "${roster_url}" 2>/dev/null)
    if [[ ${group_id} -gt 0 ]]; then
	printf "%s" "${group_id}"
    else
	return 1
    fi
}

function ret_vevent_organizer_value() {
    ## return vevent organizer value
    ics_organizer_cnparam="${app_name}"
    ics_organizer_dirparam="DIR=\"${roster_url}\""
    ics_organizer_mailtoparam="MAILTO:${ics_organizer_email}"
    ics_organizer_cnparam="CN=${ics_organizer_cn}"
    ics_organizer_sentbyparam="SENT-BY=\"MAILTO:${ics_organizer_sentby_email}\""
    ics_organizer_value="ORGANIZER;${ics_organizer_cnparam};${ics_organizer_dirparam};${ics_organizer_sentbyparam}:${ics_organizer_mailtoparam}"
    ics_organizer_value="$(wrap_lines "${ics_organizer_value}")"
    printf "%s\n" "${ics_organizer_value}"
}

function ret_vevent_summary() {
    ## return the value for a SUMMARY line for a VEVENT
    course="$1"
    course_lc="${course,,}"
    ## use the courses label if it is defined
    if [[ ${labels_courses[${course_lc}]+x} ]]; then
	course_label="${labels_courses[${course_lc}]}"
    else
	course_label="${course}"
    fi
    printf "%s" "${course_label}"
}

function ret_vevent_category() {
    ## return the value for a CATEGORY line for a VEVENT
    course_lc="${1,,}"
    category_value=""
    case ${course_lc} in
	*"toets"*|*"test"*)
	    category_value="${labels_rosteritemcategory[test]}" ;;
	*"prakt"*|*"pract"*|*"lab"*)
	    category_value="${labels_rosteritemcategory[lab]}" ;;
	*"colleg"*|*"lect"*)
	    category_value="${labels_rosteritemcategory[lecture]}" ;;
	*"worksh"*|*"slb"*|*"tutor"*|*"maple"*)
	    category_value="${labels_rosteritemcategory[workshop]}" ;;
	*)
	    category_value="${labels_rosteritemcategory[lesson]}" ;;
    esac
    printf "%s" "${category_value}"
}

function ret_vevent_dtstart() {
    ## return the value for a DTSTART line for a VEVENT
    lesson_date="$1"
    starttime="$2"
    starttime_formatted="$(date -d "${starttime}" +"${ics_dt_timeformat}")"
    printf "TZID=%s:%s%s" \
	   "${ics_dt_timezoneid}" "${lesson_date}" "${starttime_formatted}"
}

function ret_vevent_dtend() {
    ## return the value for a DTEND line for a VEVENT
    lesson_date="$1"
    starttime="$2"
    endtime_formatted="$(date -d "${starttime} sec + \
${lessonduration_minutes} min - 1 sec" +"${ics_dt_timeformat}")"
    printf "TZID=%s:%s%s" \
	   "${ics_dt_timezoneid}" "${lesson_date}" "${endtime_formatted}"
}

function ret_teacher_props() {
    ## use teacher abbreviation $1 (id) to return newline separated
    ## teacher name, email and id from lavels_teachers array
    ## containing all csv records.
    teacher_abbrev="$1"
    teacher_csv="${labels_teachers[${teacher_abbrev}]}"
    teacher_re="(.*)[[:space:]]+mailto:(.*)[[:space:]]+dir:(.*)$"
    if [[ "${teacher_csv}" =~ ${teacher_re} ]]; then
	printf '%s\n' "${BASH_REMATCH[@]:1}"
    else
	printf 1>&2 "\n%s: teacher abbreviation \`%s' not found in teachers csv file \`%s'.\n" \
		    "${FUNCNAME[0]}" "${teacher_csvfield}" "${csv_paths["teachers"]}"
	printf 1>&2 "consider adding it using:\n%s\n" \
		    "${people_lookup_url_base}"
	return 1
    fi
}

function ret_vevent_attendeechair() {
    ## return the value for an ATTENDEE line for a VEVENT
    teacher_abrrev="$1"
    ## make sure each array item contains a complete line 
    IFS=$'\n' teacher_props=( $(ret_teacher_props "${teacher_abrrev}") )
    teacher_name="${teacher_props[0]}"
    teacher_mail="${teacher_props[1]}"
    teacher_id="${teacher_props[2]}"
    if [[ "${teacher_mail}x" == "x" ]]; then
	attendeechair="CN=${teacher_name}"	    
    else
	if [[ "${teacher_id}x" == "x" ]]; then
	    attendeechair="CN=${teacher_name};RSVP=FALSE:MAILTO:${teacher_mail}"
	else
	    attendeechair="CN=${teacher_name};DIR=\"${ics_organizer_dirurl}${teacher_id}\";RSVP=FALSE:MAILTO:${teacher_mail}"		
	fi
    fi
    printf "%s" "${attendeechair}"
}

function ret_vevent_location() {
    ## return the value for a LOCATION line for a VEVENT.
    ## expects a room name (eg. 'L121') with or without a room
    ## capacity between parenthesis 'G106 (45)'
    room=${1//\\n/ }
    room=$(echo ${room})
    room_with_capacity_re="(.*)[[:space:]]\(([0-9]+)\)"
    if [[ ${room} =~ ${room_with_capacity_re} ]]; then
	## capacity field contains number
	room_name=${BASH_REMATCH[1]}
	room_capacity=${BASH_REMATCH[2]}
	if (( 30<=room_capacity && room_capacity<45 )); then
	    room_type="small"
	elif (( 45<=room_capacity && room_capacity<80 )); then
	    room_type="moderate"		
	elif (( 80<=room_capacity )); then
	    room_type="large"
	else
	    room_type="default"
	fi
	location_value="${labels_roomcapacity[${room_type}]} ${room_name}"
    else
	## no capacity field or one with non-numeric items
	for key in "${!labels_roomcapacity[@]}"; do
	    if [[ "${room,,}" =~ ${key} ]]; then
		location_value="${labels_roomcapacity[${key}]} ${room}"
		break
	    fi
	done
	if [[ "${location_value}x" == "x" ]]; then 
	    location_value="${labels_roomcapacity[default]} ${room}"
	fi
	[[ ${DEBUG} ]] && \
	    printf 1>&2 "%s: location_value=\`%s'\n" \
			"${FUNCNAME[0]}" "${location_value}"
    fi
    printf "%s" "${location_value}"    
}

function parse_raw_roster_line() {
    ## extracts and returns newline separated coursename,
    ## roomcapacity, roomnumber and teacherabbrev field values for
    ## roster line $1
    roster_line_raw="$1"
    printf -v error_header "\n%5sANOMALITY in %s" "${FUNCNAME[0]}"
    ## convert multiple consequetive spaces and newline chars to single space
    roster_line_stripped=$(echo ${roster_line_raw})
    ## only proceed for non-empty and non single number lines
    if [[ "${roster_line_stripped}x" == "x" ]]; then	
	return 1
    fi
    ## original: `BM3-Bioinformatica KKE      101 inf   (30)'
    ## 1. strip extra spaces:
    roster_line_stripped="${roster_line_stripped//  / }"
    ## rest:     `BM3-Bioinformatica KKE 101 inf (30)'
    ## 2. handle exception for 'infinite' roomnumbers:
    ##    roombumber '101 inf':
    roster_line_fixed="${roster_line_stripped// inf/}"
    ## rest:     `BM3-Bioinformatica KKE 101 (30)`
    ## 3. handle exception for 'Surveillance' roomnumbers:
    ##    teacher_abbrev 'Surv':
    roster_line_fixed="${roster_line_fixed//Surv/SURV}"
    roomcapacity_re="[[:space:]]\(([0-9]+)\)$"
    ## 4. strip roomcapacity:
    ## 4.a add dummy capacity '(0)':
    if [[ ! "${roster_line_fixed}" =~ ${roomcapacity_re} ]]; then
	roster_line_fixed="${roster_line_fixed} (0)"
    fi
    ## try again with dummy capacity field
    if [[ ! "${roster_line_fixed}" =~ ${roomcapacity_re} ]]; then
	printf 1>&2 "%s: roster_line_fixed=\`%s' does not match roomcapacity_re=\`%s'.\n" \
		    "${error_header}" "${roster_line_fixed}" "${roomcapacity_re}"
	return 1
    else
	roomcapacity="${BASH_REMATCH[1]}"
	roster_line_rest="${roster_line_fixed//(${roomcapacity})/}"
	roster_line_rest="${roster_line_rest%% }"
	## 5. strip the roomnumber:
	roomnumber_re="([^[:space:]]+)[[:space:]]*$"
	if [[ "${roster_line_rest}" =~ ${roomnumber_re} ]]; then
	    roomnumber="${BASH_REMATCH[1]}"
	    roster_line_rest="${roster_line_rest//${roomnumber}/}"
	    roster_line_rest="${roster_line_rest%% }"
	else
	    printf 1>&2 "%s: roster_line_rest=\`%s' does not contain a roomnumber.\n" \
			"${error_header}" "${roster_line_rest}"
	    return 1
	fi
	## 6. strip the teacher_abbrev:
	teacherabbrev_re="[[:space:]]([A-Z]+)$"
	if [[ "${roster_line_rest}" =~ ${teacherabbrev_re} ]]; then
	    teacherabbrev="${BASH_REMATCH[1]}"
	    coursename="${roster_line_rest// ${teacherabbrev}/}"
	    ## return the results
	    res=("${coursename}"
		 "${roomcapacity}"
		 "${roomnumber}"
		 "${teacherabbrev}")
	    printf "%s\n" "${res[@]}"
	else
	    printf 1>&2 "%s: roster_line_rest=\`%s' does not contain a teacherabbrev.\n" \
			"${error_header}" "${roster_line_rest}"
	    return 1
	fi
    fi
}


 function parse_roster_item() {
     ## parse space separated lesson name, teacher abbrev (#n-1) and
     ## room (#n), in that particular numbered weekday $2 and lesson
     ## hour. In case of tests (instead of lessons), a <br> multiline
     ## string, where each line consists of (space separated) test
     ## name, a hyphen '-' (n-1) and room (n).
     ## Teacher abbrev (eg. SDKN) to name:
     ##  https://www1.han.nl/insite/sb/home_opl.xml?content=/onze_mensen
     ## tests (Description=Toets ...) have a hyphen '-' instead of a
     ## teacher abbrev.
     week_startdate="$1"
     ## weekday 0=monday
     weekday="$2"
     roster_line_raw="$3"
     declare -a rosteritem_props
     rosteritem_props=($(parse_raw_roster_line "${roster_line_raw}"))
     if [[ $? -ne 0 ]] || [[ ${#rosteritem_props[@]} -ne 4 ]]; then
	 return 1
     fi
     coursename_fieldvalue="${rosteritem_props[0]}"
     roomcapacity_fieldvalue="${rosteritem_props[1]}"
     roomnumber_fieldvalue="${rosteritem_props[2]}"
     teacherabbrev_fieldvalue="${rosteritem_props[3]}"
     ## start processing
     starttime="${starting_hours[${lesson_hour}]}:00"
     ## BEGIN
     vevent=("\nBEGIN:VEVENT")
     ## LOCATION
     location_value="$(ret_vevent_location "${roomnumber_fieldvalue}")"
     vevent+=("LOCATION:${location_value}")
     ## ORGANIZER
     ## ";" cnparam ";" dirparam ";" sentbyparam) / (";" languageparam) /
     vevent+=("${ics_organizer_value//\n\n/}")
     ## ATTENDEE;ROLE=CHAIR
     chair_value="$(ret_vevent_attendeechair "${teacherabbrev_fieldvalue}")"
     if [[ $? -eq 0 ]]; then
	 chair_value="ATTENDEE;ROLE=CHAIR;${chair_value}"		
	 chair_value="$(wrap_lines "${chair_value}")"		
	 vevent+=("${chair_value//\n\n/}")
     fi
     lesson_date="$(date -d "${week_startdate} + ${weekday} day" +"%Y%m%d")"
     ## DTSTART
     vevent+=("DTSTART;$(ret_vevent_dtstart "${lesson_date}" "${starttime}")")
     ## DTEND
     vevent+=("DTEND;$(ret_vevent_dtend "${lesson_date}" "${starttime}")")
     ## DTSTAMP
     vevent+=("DTSTAMP;TZID=${ics_dt_timezoneid}:$(date +"%Y%m%dT%H%M%S")")
     ## UID
     vevent+=("UID:${app_name}@${RANDOM}$(date +"%Y%m%d%H%M%S")")
     ## SUMMARY
     vevent+=("SUMMARY:$(ret_vevent_summary "${coursename_fieldvalue}" )")
     category_value="$(ret_vevent_category "${coursename_fieldvalue}")"
     vevent+=("CATEGORIES:${category_value}")
     ## add PRIORITY for tests
     if [[ "${labels_rosteritemcategory[test]}" == "${category_value}" ]]; then
	 vevent+=("PRIORITY:1")	
     fi
     ## CLASS: public, private or confidential
     ## http://www.kanzaki.com/docs/ical/class.html
     vevent+=("CLASS:PUBLIC")
     ## TRANSP: indicates free/busy status in clients (opaque = busy)
     ## http://www.kanzaki.com/docs/ical/transp.html
     vevent+=("TRANSP:OPAQUE")
     ## X-MOZ-SEND-INVITATIONS
     vevent+=("X-MOZ-SEND-INVITATIONS:FALSE")
     ## END
     vevent+=("END:VEVENT")
     printf "%s\n" "${vevent[@]}"	
 }

 function parse_roster_lines_xml() {
     ## return the text containing the roster items for this week in
     ## the xml //table[@class=data] field
     xml_source="$1"
     weekday="$2"
     lesson_hour="$3"
     ## starting with the first tr (lesson hour) element, select the n-th tr element,
     ## where n=${lesson_hour}, essentially skipping the first one,
     ## which contains row headings
     weekday_offset=2
     weekday_tdselector=$(( weekday + weekday_offset ))
     q_xpath="//tr[1]/following-sibling::*[${lesson_hour}]/*[${weekday_tdselector}]/text()"
     xmllint_args+=(--xpath "${q_xpath}")
     res="$(XMLLINT_INDENT=2 ${cmd_xmllint} "${xmllint_args[@]}" - <<<"${xml_source}" 2>/dev/null)"
     if [[ $? -ne 0 ]] || [[ "${res// /}x" == "x" ]]; then
	 return 1
     else
	 ## return the xml
	 res="${res//$'\n'/}"
	 res="${res//#/$'\n'}"
	 printf "%s\n" "${res}"
     fi
 }

 function parse_roster_hours() {
     week_startdate="$1"
     xml_parsed="$2"
     ## wrapper (weekday 0=monday!)
     for weekday in {0..5}; do 
	 for lesson_hour in {1..18}; do 
	     res="$(parse_roster_lines_xml "${xml_parsed}" "${weekday}" "${lesson_hour}")"
	     while read -r line; do
		 parsed_props="$(parse_roster_item "${week_startdate}" "${weekday}" "${line}")"
		 printf 1>&2 "."
		 ## parsed_props contains formatting
		 # shellcheck disable=SC2059
		 printf "${parsed_props}"
	     done<<<"${res}"
	 done
     done 
 }

 function ret_weekly_timetable_parsedxml() {
     ## wrapper for html and xml fetching and fixing
     ## returns a valid xml snippet representing the weekly timetable
     ## for group_id $1 and start_date $2
     group_id="$1"
     start_date="$2"
     
     xml_rawsource="$(ret_weekly_timetable_html "${group_id}" "${start_date}")"
     if [[ $? -ne 0 ]]; then
	 printf "error: ret_weekly_timetable_html returned:\n%s\n" "${xml_rawsource}"
	 return 1
     else 
	 xhtml_clean="$(fix_html "${xml_rawsource}")"
	 if [[ $? -ne 0 ]]; then
	     printf "error: fix_html returned:\n%s\n" "${xhtml_clean}"
	     return 1
	 else
	     xml_parsed="$(parse_xml "${xhtml_clean}")"
	     if [[ $? -ne 0 ]]; then
		 printf "error: parse_xml returned:\n%s\n" "${xml_parsed}"		
		 return 1
	     else 
		 printf "%s" "${xml_parsed}"
	     fi
	 fi
     fi
 }

 function ret_weekly_timetable_html() {
     ## use curl to fetch and return html for specified group and start
     ## date
     group_id="$1"
     start_date="$2"
     ## format needed for getting and parsing html: M/D/YYYY,
     ## eg '1/2/2016' for the second of january 2016
     start_date_untis="$(ret_untis_date "${start_date}")"
     query_data="groep=${group_id}&StartWeek=${start_date_untis}"
     curl_params=(--silent)
     curl_params+=(--data "${query_data}")
     curl_res="$(${cmd_curl} "${curl_params[@]}" "${roster_url}" 2>/dev/null)"
     if [[ $? -ne 0 ]]; then
	 printf 1>&2 "error in %s\n\tusing data param \`%s' for group_id \`%s' \
and start_date \`%s'.\n" \
		     "${FUNCNAME[0]}" "${query_data}" "${group_id}" "${start_date}"
	 return 1
     else
	 printf "%s\n" "${curl_res}"
     fi
 }

 function fix_html() {
     ## use tidy to clean up incoming html
     ## replace unclosed/invalid br elements ('<br>') with '#',
     ## indicating a new line has been started (applicable to 'test'
     ## courses).
     html_rawsource="${1//<br>/#}"
     tidy_args=(-asxml)
     tidy_args+=(-utf8)
     tidy_args+=(--doctype "omit")
     tidy_args+=(--output-xml "yes")
     tidy_args+=(-indent)
     tidy_args+=(-clean)
     tidy_args+=(-bare)
     tidy_args+=(-numeric)
     tidy_args+=(--enclose-text "yes")
     tidy_args+=(-quiet)
     res="$(${cmd_tidy} "${tidy_args[@]}" 2>/dev/null <<<"${html_rawsource}")"
     if [[ $? -gt 1 ]]; then
	 printf "%s: error running tidy:\n%s\n" \
		"${FUNCNAME[0]}" "${res}"
	 return 1
     else
	 printf "%s\n" "${res}"
     fi
 }

 function parse_xml() {
     ## filter incoming cleaned html ($1) using xsl to select the table
     ## element which contains the real timetable data.
     ## returns the selected xml.
     xhtml_clean="$1"
     q_xpath='//table//table[@class="data"]'
     xmllint_args+=(--xpath "${q_xpath}")
     res="$(${cmd_xmllint} "${xmllint_args[@]}" - <<<"${xhtml_clean}" 2>/dev/null)"
     if [[ $? -ne 0 ]]; then
	 printf "%s: error running xmllint:\n%s\n" \
		"${FUNCNAME[0]}" "${res}"
	 return 1
     else
	 ## return the xml
	 printf "%s\n" "${res//\"/\'}"
     fi
 }

 function ret_untis_date() {
     ## return the German formatted date Untis uses.
     ## eg, M/D/YYYY, stripping any leading zeroes for M and D
     date="$1"
     leadingzeroes_re="^0([0-9]+)$"
     ## get month and day numbers, stripping any leading '0'
     year="$(date -d "${date}" +'%Y')"
     monthnum="$(date -d "${date}" +'%m')"
     if [[ "${monthnum}" =~ ${leadingzeroes_re} ]]; then 
	 monthnum="${BASH_REMATCH[1]}"
     fi
     daynum="$(date -d "${date}" +'%d')"
     if [[ "${daynum}" =~ ${leadingzeroes_re} ]]; then 
	 daynum="${BASH_REMATCH[1]}"
     fi
     ## return the result
     printf "%s/%s/%s" \
	    "${monthnum}" "${daynum}" "${year}"
 }

 function check_sanity() {
     cmd_xmllint="$(type -p xmllint || return 1)"
     cmd_curl="$(type -p curl || return 1)"
     cmd_tidy="$(type -p tidy || return 1)"
     if [[ -f "${output_path}x" ]]; then
	 if [[ "${overwrite_output}x" == "x" ]]; then 
	     # TODO; add overwrite option
	     die "output_path \`${output_path}' already exists and argument --overwrite-output not set.\n"
	 else
	     printf 1>&2 "NOTICE: argument --overwrite-output is set; overwriting existing ics file \`%s'.\n" \
			 "${output_path}"
	 fi
     fi
     printf 1>&2 "%3s- managing temporary storage directory ... " " "
     if [[ "${temp_storage_dir}x" == "x" ]]; then
	 temp_storage_dir="$(mktemp -d "/tmp/${app_name}_temp_XXXXX")"
	 if [[ $? -ne 0 ]]; then
	     printf 1>&2 "error.\n"
	     printf -v msg_err "could not create temporary directory using \`%s'.\n" \
		    "mktemp -d \"/tmp/${app_name}_temp_XXXXX\""
	     die "${msg_err}"
	 else
	     printf 1>&2 "done.\n"
	     printf 1>&2 "%5s* \`%s' (%s).\n" \
			 " " \
			 "${temp_storage_dir}" \
			 "using temporary directory"
	 fi
     else
	 if [[ ! -d "${temp_storage_dir}" ]]; then
	     res="$(mkdir -pv "${temp_storage_dir}" 2>&1)"
	     if [[ $? -ne 0 ]]; then
		 printf 1>&2 "error.\n"
		 printf -v msg_err "could not create specified temporary directory \`%s'.\nmkdir returned error:\n%s\n" \
			"${temp_storage_dir}" "${res}"
		 die "${msg_err}"
	     else
		 printf 1>&2 "done.\n"
		 printf 1>&2 "%5s* \`%s' (%s).\n" \
			     " " \
			     "${temp_storage_dir}" \
			     "new storage directory created"
	     fi
	 else
	     printf 1>&2 "done.\n"
	     printf 1>&2 "%5s* \`%s' (%s).\n" \
			 " " \
			 "${temp_storage_dir}" \
			 "reusing existing storage directory"
	     
	 fi
     fi
 }

 function write_ics() {
     ## creates ics file $1 using a temporary file 
     tempfile="$(mktemp "/tmp/${app_name}.XXXX")"
     printf "%s" "${ics_header}" > ${tempfile}
     printf 1>&2 "%3s- merging weekly ics snippets " " "
     for ics_snippet in ${temp_storage_dir}/*.ics; do
	 vevent_ics="$(<${ics_snippet})"
	 if [[ "${vevent_ics}x" == "x"  ]]; then
	     printf 1>&2 "%s" "-"
	 else
	     printf "%s\n" "${vevent_ics}" >> ${tempfile}
	     printf 1>&2 "%s" "+"
	 fi
     done
     ## add the footer
     printf "%s" "${ics_footer}" >> ${tempfile}
     ## convert tempfile to the actual output file
     replace_newline_with_crlf "${tempfile}" "${output_path}" && \
	 rm "${tempfile}"
     printf 1>&2 " done.\n"
 }

 function process_weeks() {

     printf 1>&2 "%3s- getting id for group \`%s' ... " \
		 " " \
		 "${group_name}"
     group_id="$(ret_group_id "${group_name}")"
     if [[ $? -ne 0 ]]; then
	 printf -v msg_error \
		"errors occured.\ncould not get group_id for group \`%s' using url \`%s'\n" \
		"${group_name}" \
		"${roster_url}"
	 die "${msg_error}"
     else
	 printf 1>&2 "done.\n%5s* group_id=%d\n" \
		     " " "${group_id}"
     fi
     # shellcheck disable=SC2183
     printf -v rundate_real "%(%Y%m%d)T"
     ## current weekday num (monday=1)
     # shellcheck disable=SC2183
     printf -v rundate_weekdaynum "%(%u)T"
     ## substract n days from the current date to get the first day
     ## (monday) of this week, where n is the current day number - 1
     ## first run
     week_counter=0
     rundate_firstdayofweek="$(date -d "${rundate_real} - $(( rundate_weekdaynum - 1 ))day" \
 +"%Y%m%d")"
     cur_date="${rundate_firstdayofweek}"
     printf 1>&2 "%3s- fetching weekly timetables for group %s (id=%d) from \`%s' ...\n" \
		 " " \
		 "${group_name}" \
		 "${group_id}" \
		 "${roster_url}"
     ## process each week
     while ((0<=week_counter && week_counter<=weeks_ahead - 1)); do
	 cur_weeknum="$(date -d "${cur_date}" "+%V")"
	 cur_year="$(date -d "${cur_date}" "+%Y")"
	 cur_filename="${cur_year}_${cur_weeknum}.${app_name}.ics"
	 printf 1>&2 "%5s* week %2s of %s: %s/%s " \
		     " " \
		     "$((week_counter + 1))" \
		     "${weeks_ahead}" \
		     "${cur_weeknum}" \
		     "${cur_year}"
	 ## get xml with this weeks timetable information
	 xml_parsed="$(ret_weekly_timetable_parsedxml "${group_id}" "${cur_date}")"
	 if [[ $? -ne 0 ]]; then
	     printf 1>&2 "error getting or parsing xml:\n%s\n" "${xml_parsed}"
	     break
	 fi
	 res="$(parse_roster_hours "${cur_date}" "${xml_parsed}")"
	 if [[ $? -eq 0 ]] && [[ -f "${temp_storage_dir}/${cur_filename}" ]]; then 
	     rm -f "${temp_storage_dir}/${cur_filename}"
	 fi
	 printf "%s\n" "${res}" > "${temp_storage_dir}/${cur_filename}"
	 printf 1>&2 " done\n" 
	 ## forward one week
	 cur_date="$(date -d "${cur_date} + 7days" +"%Y%m%d")"
	 (( week_counter++ ))
     done
 }

 function handle_symlinks() {
     ## creates symlinks to output_path in its directory 
     target_filename="$(basename "${output_path}")"
     target_dir="$(dirname "$(readlink -f "${output_path}")")"
     ln_args=(--symbolic)
     ln_args+=(--no-target-directory)
     declare -a symlinks_done
     if [[ "${overwrite_symlinks}x" != "x" ]]; then
	 ln_args+=(--force)
     fi
     for symlink_name in "${a_symlink_names[@]}"; do
	 link_path="${target_dir}/${symlink_name}"
	 if [[ -e "${link_path}" ]] && [[ ! -L "${link_path}" ]]; then
	     printf 1>&2 "error in %s: will not overwrite existing file/directory \`%s'.\n" \
			 "${FUNCNAME[0]}" \
			 "${link_path}"
	 else
	     ln "${ln_args[@]}" "${target_filename}" "${link_path}"  || \
		 return 1 && \
		     symlinks_done+=("      ${link_path} -> ${target_filename}")
	 fi
     done
     printf 1>&2 "%3s- symlinks created:\n" " "
     printf 1>&2 "%s\n" "${symlinks_done[@]}"
 }

 ## main
 curdir="$(pwd)"
 declare arg_settings_file arg_roster_url arg_group_name \
	 arg_temp_storage_dir \
	 arg_output_path arg_symlink_path \
	 arg_standard_group_size arg_weeks_ahead \
	 arg_lessonduration_minutes arg_teachers_csv_path arg_courses_csv_path \
	 arg_overwrite_output arg_overwrite_symlinks  \
	 arg_ics_organizer_email arg_ics_organizer_cn arg_ics_organizer_sentby_email \
	 arg_people_lookup_url_base arg_ics_organizer_dirurl

 declare roster_url group_name output_path \
	 symlink_path \
	 standard_group_size weeks_ahead lessonduration_minutes \
	 teachers_csv_path courses_csv_path \
	 overwrite_output overwrite_symlinks \
	 ics_organizer_email ics_organizer_cn ics_organizer_sentby_email \
	 people_lookup_url_base ics_organizer_dirurl \
	 cmd_xmllint cmd_curl cmd_tidy
 declare -a xmllint_args errors a_symlink_names
 declare -A csv_paths labels_courses labels_teachers labels_roomcapacity

 xmllint_args=(--xmlout)
 xmllint_args+=(--encode "UTF-8")
 xmllint_args+=(--format)
 xmllint_args+=(--nowrap)
 xmllint_args+=(--html)
 xmllint_args+=(--pretty "1")

 printf 1>&2 "%3s- analyzing command line arguments ... " " "
 analyze_command_line "$@"
 if [[ $? -ne 0 ]]; then
     printf 1>&2 " error.\n"
     die "errors encountered analyzing command line arguments."
 fi

 ## required arguments
 declare -a errors
 if [[ "${arg_roster_url}x" == "x" ]] && [[ "${roster_url}x" == "x" ]]; then
     errors+=("required argument -u|--roster-url not specfied.")
 fi
 if [[ "${arg_group_name}x" == "x" ]] && [[ "${group_name}x" == "x"  ]]; then
     errors+=("required argument -g|--group-name not specfied.")
 fi
 if [[ ${#errors[@]} -gt 0 ]]; then
     printf -v msg_error "%s\n" "${errors[@]}"
     die "${msg_error}"
 fi
 ## set up translation tables
 labels_roomcapacity[small]="Leslokaal"
 labels_roomcapacity[moderate]="Praktijklokaal"
 labels_roomcapacity[large]="Collegezaal"
 labels_roomcapacity[default]="Lokaal"
 labels_roomcapacity[kantine]=""
 declare -A labels_rosteritemcategory
 labels_rosteritemcategory[test]="Toets"
 labels_rosteritemcategory[lab]="Practicum"
 labels_rosteritemcategory[lesson]="Les"
 labels_rosteritemcategory[lecture]="College"
 labels_rosteritemcategory[guestlecture]="Gastcollege"
 labels_rosteritemcategory[workshop]="Werkcollege"
 array_from_csv "courses" "2" || exit 1
 array_from_csv "teachers" "5" || exit 1

 ics_organizer_value="$(ret_vevent_organizer_value)"
 starting_hours=("08:00"
		 "08:45"
		 "09:30"
		 "10:30"
		 "11:15"
		 "12:00"
		 "12:45"
		 "13:30"
		 "14:15"
		 "15:15"
		 "16:00"
		 "16:45"
		 "17:30"
		 "18:15"
		 "19:00"
		 "19:45"
		 "20:30"
		 "21:15"
		 "22:00")
 ics_dt_timeformat="T%H%M%S"
 ics_dt_timezoneid="Europe/Amsterdam"

 # shellcheck disable=SC1078,SC1079,SC1089
 ics_header="""\
BEGIN:VCALENDAR
VERSION:2.0
CALSCALE:GREGORIAN
PRODID:-//Lacocina//NONSGML ${ics_organizer_cnparam}//EN
BEGIN:VTIMEZONE
TZID:${ics_dt_timezoneid}
X-LIC-LOCATION:${ics_dt_timezoneid}
BEGIN:DAYLIGHT
TZOFFSETFROM:+0100
TZOFFSETTO:+0200
TZNAME:CEST
DTSTART:19700329T020000
RRULE:FREQ=YEARLY;BYMONTH=3;BYDAY=-1SU
END:DAYLIGHT
BEGIN:STANDARD
TZOFFSETFROM:+0200
TZOFFSETTO:+0100
TZNAME:CET
DTSTART:19701025T030000
RRULE:FREQ=YEARLY;BYMONTH=10;BYDAY=-1SU
END:STANDARD
END:VTIMEZONE"""
 ics_footer="""
END:VCALENDAR"""

 check_sanity || exit 1

 ## append default to array
 labels_teachers[-]="(no teacher) mailto:(n/a) dir:(n/a)"
 process_weeks && write_ics
 printf 1>&2 "%3s- resulting ics calendar published in:\n" \
	     " "
 printf "%6s%s" " " "${output_path}"
 printf 1>&2 "\n"
 if [[ "${a_symlink_names}x" != "x" ]]; then
     handle_symlinks
 fi
 printf 1>&2 "all done.\n\n"

